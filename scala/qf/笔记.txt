
--------------------------------------------
day01


Scala介绍
	Hadoop	Java
	Hive	Java
	Spark	Scala
	Kafka	Scala
	Akka	Scala
	目标：能够开发基于Spark的应用程序，能够理解并应用函数式编程思想
	
	作者：马丁
	Pizza 实现函数式编程 Scala的前身
	
	方向：面向对象、函数式编程
	

变量的声明
	val 修饰的变量是指其引用不可变
	

数据类型
	一切类的基类是Any
	AnyRef：是Any的子类，是所有引用类型的基类
	AnyVal：是Any的子类，是所有值类型的基类
	AnyVal的子类：9个
		Byte、Char、Short、Int、Long、Float、Double----7个值类型
		Boolean、Unit---非数值类型 ， 其中Unit代表void，没有返回值，用“()”代表
		
	Scala里是没有包装类型

条件表达式
	Scala支持返回值为混合类型的表达式
		val z = if(x > 1) 1 else if(x == 0) 0 else "Error"

循环
	for(i <- 0 to arr.length - 1) {
		if(arr(i) % 2 == 0) println(arr(i))
	}
	
	until和to方法的区别
	
	map和foreach的应用场景
	map：要求有返回的时候需要用到
	foreach：一般在做数据持久化的时候用到
	
	

方法和函数
	def m1(x: Int, y: Int): Int = {x * y} // 有参数有返回的方法，可以不加返回值类型，自己可以类型推断。当该方法属于递归方法时，必须指定返回类型。
	 def m2(x: Int): Unit = {x + 1} // 没有返回值的方法
	 def m2(x: Int){x + 1} // 没有返回值的方法（不加“=”,默认没有返回值）
	 
	  val f1 = (x: Int, y: Int) => x * y // 有参有返回值的函数
	  val f2 = () => 100 * 2 // 没有返回值的函数
	  (x: Int, y: Int) => x * y // 匿名函数（没有变量接收，代表没有函数签名，就称作匿名函数）
	  
	  val f2: Int => Int = x => x * x // 函数的另外一种声明方式
	  
	  方法可以转换为函数，需要用到空格加“_”
	  如果将方法以值的形式传递到方法中去，这个过程其实是方法隐式的转换为了函数


      
--------------------------------------------
day02

集合：
	数组
	
	Map（映射）
	
	元组
	
	列表
	分可变和不可变列表
	组成：一个列表要么为空，要么是一个head元素加一个tail列表
	
	Set
	
懒加载：
	延迟加载，在调用的时候加载其值
	
常用方法练习

Scala实现单词计数


--------------------------------------------
day03


定义类和属性

构造器和辅助构造器

单例对象

伴生对象

apply方法、unapply方法

特质、抽象类、实现、继承

private关键字

模式匹配


--------------------------------------------
day04


private关键字

柯里化
是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数
柯里化方法中应用隐式值的时候，在同一个作用域中，同类型的隐式值不能定义多个，此时会出错（模糊不清的隐式的值）

隐式转换
定义：是指以implicit关键字声明的带有单个参数的函数
作用：隐式的对类做方法的增强
继承：显式的做了父类的方法增强
代理模式：主要是用作服务和服务之间的通讯
装饰模式：装饰也叫包装
	实现IO流：new BufferInputStream(new FileInputStread).read
	
隐式转换其实用到了装饰模式和门面模式
	装饰模式是用到了显式的包装
	门面模式：做了包装，用户在操作的时候，不用关心内部的具体实现。Scala的Predef就用到了门面


泛型
	[B <: A] upper bounds	上限或上界：是指B类型的上界是A类型，也就是B类型的父类是A类型
	[B >: A] lower bounds	下限或下界：是指B类型的下界是A类型，也就是B类型的子类是A类型
	[B <% A] view bounds	视界：是指B类型要转换为A类型，操作的时候需要一个隐式转换函数
	[B : A] context bounds	上下文界定：实现了隐式参数的语法糖，需要一个隐式值
	
	[-T] 逆变：作为参数类型。是指实现的参数类型是接口定义的参数类型的父类
	[+T] 协变：作为返回类型。是指返回类型是接口定义返回类型的子类


线程池、多线程、Future


--------------------------------------------
day05

注解：
可以作用于vals, vars, defs, classes, objects, traits 和 types甚至是表达式的后面。

@transient
一般用于序列化的时候，标识某个字段不用被序列化。

@Unchecked
一般是在模式匹配的时候用到的，告诉编译器有些地方不用"检查"了。

@inline
能够避免方法的参数被放到栈上，以及"显示的调用"。因为编译器在编译的时候会将整个方法复制到它被调用的地方。

@tailrec
这个注解是与尾递归优化有关的，告诉编译器这个函数是递归的，在栈桢的管理上，希望编译器能有所优化。

@volatile
实际上这个注解或是关键字，大多用于被并发访问的共享变量。在JVM内存模型中happens-before规则有一条就是volatile变量法则(有兴趣可以阅读Java并发编程实践 第16章Java内存模型)，对于volatile变量，同一变量的写操作总是先于读操作。


--------------------------------------------
千锋_回顾Scala的重点


Scala的基本语法：
	变量的定义：val、var
	条件表达式、块表达式、混合表达式
	循环：for、while  有很多批处理的方法里面就是调用的for或while循环
	方法和函数的声明
	集合：
		数组：定长和变长
		元组：Tuple+数字
		Map：不可变和可变
		List：不可变和可变
		Set：不可变和可变
		
	常用方法：map、flatMap、mapValues、foreach、reduce、fold、aggregate、filter、zip、groupBy、sortBy、sortWith
	
	面向对象
	
	模式匹配
	
	高阶函数：
		作为值的函数
		闭包
		柯里化
		隐式转换函数
	
	泛型
	
Netty

Akka







